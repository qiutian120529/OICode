# 字符串哈希

## 定义

我们定义一个把字符串映射到整数的函数 $f$，这个 $f$ 称为是 Hash 函数。我们希望这个函数 $f$ 可以方便地帮我们判断两个字符串是否相等。

## 性质
具体来说，哈希函数最重要的性质可以概括为下面两条：
- 在 Hash 函数值不一样的时候，两个字符串一定不一样；
- 在 Hash 函数值一样的时候，两个字符串可能不一样。

## Hash 函数

对于字符串，将其转化为哈希值需以下几个步骤：

1. 对于每个字符 $c_i$，将 $c_i$ 转为 int 类型的 ASCII 值 aci。
2. 将上次哈希值 res 与这次的 ASCII 值拼接起来，即 `res = (res * base + aci) % mod`。

以上就是 Hash 函数。

## Hash 冲突

我们设 Hash 的取值空间（所有可能出现的字符串的数量）为 $d$，计算次数（要计算的字符串数量）为 $n$。

则 Hash 冲突的概率为：

$$ p(n, d) = 1 - \frac{d!}{d^n(d-n)!}  \approx 1 - \exp(-\frac{n(n - 1)}{2d}) $$

可以发现，这个概率并不低。所以可以采取双模数（多模数）哈希以减小冲突概率。

# KMP

## 定义
给定一个长度为 $n$ 的字符串 $s$，其 **前缀函数** 被定义为一个长度为 $n$ 的数组 $\pi$。其中 $\pi_i$ 的定义是：
1. 如果子串 $s_{0\dots i}$ 和 $s_{i - (k - 1)\dots i}$，那么 $\pi _i$ 就是这个相等的真前缀（或者真后缀，因为它们相等）的长度，也就是 $\pi_i=k$;
2. 如果不止有一对相等的，那么 $\pi _i$ 就是其中最长的那一对的长度；
3. 如果没有相等的，那么 $\pi_i=0$。

简单来说 $\pi_i$ 就是子串 $s_{0\dots i}$ 最长的相等的真前缀与真后缀的长度。

注意，规定 $\pi_0=0$。

$\pi$ 即为前缀函数。 

## 前缀函数的处理

如果按照朴素算法暴力循环查找，$\mathcal{O(n^3)}$ 的时间复杂度无疑是会超时的。所以我们要对前缀函数的处理过程进行若干优化：

1. 观察可得**相邻的前缀函数值至多增加 $1$**。所以只需考虑是否加一的情况即可，即当 $s_{i+1}=s_{\pi_i}$ 时，$\pi_{i + 1}= \pi_i + 1$。
2. 在 1. 的基础上可以进一步思考，当 $s_{i+1}\ne s_{\pi_i}$ 时的情况。经过推导，可得到方程 $j^{(n)} = \pi_{j^{(n-1)}-1}$，$(j^{(n - 1)} \gt 0)$，其中 $j^x < j^{x+1}$ 并表示为仅次于 $j^{x+1}$ 的第 $x$ 长度 $j^x$，使得前缀性质得以保持。

## 总结

综上，我们最终可以构建一个不需要进行任何字符串比较，并且只进行 $\mathcal{O(n)}$ 次操作的算法。

# 字典树

## 定义

字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串

## 方法

我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。

有时需要标记插入进 trie 的是哪些字符串，每次插入完成时在这个字符串所代表的节点处打上标记即可。

## 核心代码

```cpp
const int N = 5e5 + 5;
int t, n, m, a[N][30], f[N], cnt = 1;
string s;

inline void insert(const string &s){
  int u = 1;
  for(auto i : s){
    if(!a[u][i - 'a']){
      a[u][i - 'a'] = ++cnt;
    }
    u = a[u][i - 'a'];
  }
  f[u] = 1;
}

inline int query(const string &s){
  int u = 1;
  for(auto i : s){
    u = a[u][i - 'a'];
    if(!u){
      break;
    }
  }
  if(f[u] == 1){
    f[u] = 2;
    return 1;
  }
  return f[u];
}

inline void init(){
  for(int i = 1; i <= cnt; i++){
    for(int j = 0; j <= 123; j++){
      a[i][j] = 0;
    }
    f[i] = 0;
  }
  cnt = 1;
}
```